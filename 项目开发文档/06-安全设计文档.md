# 云盘系统开发文档 - 安全设计

## 1. 安全架构总览

```
┌─────────────────────────────────────────────────┐
│              安全防护层                          │
│  ┌──────────────────────────────────────┐      │
│  │  WAF防火墙 / CDN / DDoS防护           │      │
│  └──────────────────────────────────────┘      │
└─────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────┐
│              应用安全层                          │
│  ┌──────────────────────────────────────┐      │
│  │  认证授权 / 权限控制 / 数据加密       │      │
│  └──────────────────────────────────────┘      │
└─────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────┐
│              数据安全层                          │
│  ┌──────────────────────────────────────┐      │
│  │  数据加密 / 备份恢复 / 审计日志       │      │
│  └──────────────────────────────────────┘      │
└─────────────────────────────────────────────────┘
```

## 2. 认证与授权

### 2.1 JWT认证机制

#### 2.1.1 Token结构设计
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "userId": 1,
    "username": "testuser",
    "userType": 0,
    "iat": 1699000000,
    "exp": 1699007200
  },
  "signature": "HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret)"
}
```

#### 2.1.2 双Token机制
- **Access Token**: 有效期2小时，用于API访问
- **Refresh Token**: 有效期7天，用于刷新Access Token

#### 2.1.3 Token刷新流程
```
客户端                    服务端
  │                        │
  │  ──Access Token失效──▶ │
  │                        │
  │  ◀──返回401状态码───   │
  │                        │
  │  ──发送Refresh Token─▶ │
  │                        │
  │  ◀──返回新Access Token─│
  │                        │
  │  ──使用新Token请求───▶ │
  │                        │
  │  ◀──返回正常数据────   │
```

#### 2.1.4 实现代码

**后端 - JwtTokenProvider.java**
```java
@Component
public class JwtTokenProvider {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    
    @Value("${jwt.refresh-expiration}")
    private long refreshExpiration;
    
    /**
     * 生成Access Token
     */
    public String generateAccessToken(Long userId, String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);
        
        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .claim("username", username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }
    
    /**
     * 生成Refresh Token
     */
    public String generateRefreshToken(Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshExpiration);
        
        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }
    
    /**
     * 验证Token
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token);
            return true;
        } catch (ExpiredJwtException e) {
            log.error("Token已过期");
        } catch (MalformedJwtException e) {
            log.error("Token格式错误");
        } catch (SignatureException e) {
            log.error("Token签名无效");
        }
        return false;
    }
    
    /**
     * 从Token获取用户ID
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        
        return Long.parseLong(claims.getSubject());
    }
}
```

**前端 - 请求拦截器**
```typescript
// Token刷新标识
let isRefreshing = false
let requests: Array<(token: string) => void> = []

// 响应拦截器
service.interceptors.response.use(
  (response) => {
    return response.data
  },
  async (error) => {
    const { config, response } = error
    
    // Token过期
    if (response?.status === 401 && !config._retry) {
      if (!isRefreshing) {
        isRefreshing = true
        config._retry = true
        
        try {
          const authStore = useAuthStore()
          await authStore.refresh()
          
          // 重试所有等待的请求
          requests.forEach(cb => cb(authStore.token))
          requests = []
          
          return service(config)
        } catch (err) {
          // 刷新失败，跳转登录
          useAuthStore().logout()
          router.push('/login')
        } finally {
          isRefreshing = false
        }
      } else {
        // 等待Token刷新
        return new Promise(resolve => {
          requests.push((token: string) => {
            config.headers.Authorization = `Bearer ${token}`
            resolve(service(config))
          })
        })
      }
    }
    
    return Promise.reject(error)
  }
)
```

### 2.2 密码安全

#### 2.2.1 密码加密存储
使用BCrypt算法进行密码加密，每次加密结果不同（加盐）

```java
@Service
public class PasswordService {
    
    /**
     * 加密密码
     */
    public String encryptPassword(String rawPassword) {
        return BCrypt.hashpw(rawPassword, BCrypt.gensalt(10));
    }
    
    /**
     * 验证密码
     */
    public boolean matchPassword(String rawPassword, String encodedPassword) {
        return BCrypt.checkpw(rawPassword, encodedPassword);
    }
}
```

#### 2.2.2 密码强度要求
- 最小长度：6位
- 建议包含：大小写字母、数字、特殊字符
- 禁止使用：连续字符、常见密码

```typescript
// 前端密码强度检查
export const validatePassword = (password: string): boolean => {
  if (password.length < 6) {
    return false
  }
  
  // 检查是否包含至少两种类型字符
  let types = 0
  if (/[a-z]/.test(password)) types++
  if (/[A-Z]/.test(password)) types++
  if (/[0-9]/.test(password)) types++
  if (/[^a-zA-Z0-9]/.test(password)) types++
  
  return types >= 2
}
```

### 2.3 权限控制

#### 2.3.1 RBAC权限模型
```
用户(User) ─┐
            ├──▶ 角色(Role) ──▶ 权限(Permission)
管理员      ─┘
```

#### 2.3.2 权限注解
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value();
}

// 使用示例
@RequirePermission("file:delete")
public void deleteFile(Long fileId) {
    // 删除文件逻辑
}
```

#### 2.3.3 文件访问权限
```java
@Service
public class FilePermissionService {
    
    /**
     * 检查用户是否有文件访问权限
     */
    public boolean checkFilePermission(Long userId, Long fileId, String operation) {
        FileInfo file = fileMapper.selectById(fileId);
        
        if (file == null) {
            return false;
        }
        
        // 文件所有者拥有所有权限
        if (file.getUserId().equals(userId)) {
            return true;
        }
        
        // 公开文件只允许读取
        if (file.getIsPublic() == 1 && "read".equals(operation)) {
            return true;
        }
        
        // 管理员拥有所有权限
        User user = userMapper.selectById(userId);
        if (user.getUserType() == 1) {
            return true;
        }
        
        return false;
    }
}
```

## 3. 数据安全

### 3.1 敏感数据加密

#### 3.1.1 数据库敏感字段加密
```java
@Component
public class AesEncryptor {
    
    private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
    
    @Value("${encryption.key}")
    private String encryptionKey;
    
    /**
     * 加密
     */
    public String encrypt(String plainText) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                encryptionKey.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            
            byte[] encrypted = cipher.doFinal(plainText.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            throw new BusinessException("加密失败");
        }
    }
    
    /**
     * 解密
     */
    public String decrypt(String encryptedText) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                encryptionKey.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, keySpec);
            
            byte[] decrypted = cipher.doFinal(
                Base64.getDecoder().decode(encryptedText));
            return new String(decrypted);
        } catch (Exception e) {
            throw new BusinessException("解密失败");
        }
    }
}
```

#### 3.1.2 文件加密存储（可选）
```java
@Service
public class FileEncryptionService {
    
    /**
     * 加密文件
     */
    public void encryptFile(InputStream input, OutputStream output, String password) 
            throws Exception {
        SecretKeySpec keySpec = generateKey(password);
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        
        CipherOutputStream cos = new CipherOutputStream(output, cipher);
        byte[] buffer = new byte[4096];
        int bytesRead;
        
        while ((bytesRead = input.read(buffer)) != -1) {
            cos.write(buffer, 0, bytesRead);
        }
        
        cos.close();
    }
    
    /**
     * 解密文件
     */
    public void decryptFile(InputStream input, OutputStream output, String password) 
            throws Exception {
        SecretKeySpec keySpec = generateKey(password);
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        
        CipherInputStream cis = new CipherInputStream(input, cipher);
        byte[] buffer = new byte[4096];
        int bytesRead;
        
        while ((bytesRead = cis.read(buffer)) != -1) {
            output.write(buffer, 0, bytesRead);
        }
        
        cis.close();
    }
    
    private SecretKeySpec generateKey(String password) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] key = md.digest(password.getBytes());
        return new SecretKeySpec(key, "AES");
    }
}
```

### 3.2 SQL注入防护

#### 3.2.1 使用参数化查询
```java
// 安全的查询方式（MyBatis）
@Select("SELECT * FROM file_info WHERE user_id = #{userId} AND file_name LIKE CONCAT('%', #{keyword}, '%')")
List<FileInfo> searchFiles(@Param("userId") Long userId, @Param("keyword") String keyword);

// 不安全的方式（避免使用）
// String sql = "SELECT * FROM file_info WHERE file_name = '" + fileName + "'";
```

#### 3.2.2 输入验证
```java
@RestController
@Validated
public class FileController {
    
    @PostMapping("/files")
    public Result<?> createFile(@Valid @RequestBody FileCreateRequest request) {
        // 参数自动验证
        return Result.success(fileService.createFile(request));
    }
}

@Data
public class FileCreateRequest {
    
    @NotBlank(message = "文件名不能为空")
    @Size(max = 255, message = "文件名长度不能超过255")
    @Pattern(regexp = "^[^/\\\\:*?\"<>|]+$", message = "文件名包含非法字符")
    private String fileName;
    
    @NotNull(message = "父文件夹ID不能为空")
    @Min(value = 0, message = "父文件夹ID无效")
    private Long parentId;
}
```

### 3.3 XSS攻击防护

#### 3.3.1 后端防护
```java
@Component
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        XssHttpServletRequestWrapper wrapper = 
            new XssHttpServletRequestWrapper((HttpServletRequest) request);
        chain.doFilter(wrapper, response);
    }
}

public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return cleanXss(value);
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                values[i] = cleanXss(values[i]);
            }
        }
        return values;
    }
    
    private String cleanXss(String value) {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // 移除XSS攻击代码
        value = value.replaceAll("<script", "&lt;script");
        value = value.replaceAll("</script>", "&lt;/script&gt;");
        value = value.replaceAll("<iframe", "&lt;iframe");
        value = value.replaceAll("javascript:", "");
        value = value.replaceAll("onerror=", "");
        value = value.replaceAll("onclick=", "");
        
        return value;
    }
}
```

#### 3.3.2 前端防护
```typescript
// 使用DOMPurify清理HTML
import DOMPurify from 'dompurify'

export const sanitizeHtml = (html: string): string => {
  return DOMPurify.sanitize(html)
}

// Vue中使用
<div v-html="sanitizeHtml(userInput)"></div>
```

### 3.4 CSRF攻击防护

#### 3.4.1 CSRF Token
```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .and()
            .authorizeHttpRequests()
                .anyRequest().authenticated();
        
        return http.build();
    }
}
```

#### 3.4.2 同源策略
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("https://yourdomain.com")  // 指定允许的域名
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

## 4. 文件安全

### 4.1 文件类型检查

#### 4.1.1 MIME类型检查
```java
@Service
public class FileValidationService {
    
    private static final List<String> ALLOWED_MIME_TYPES = Arrays.asList(
        "image/jpeg", "image/png", "image/gif",
        "application/pdf", "text/plain",
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    );
    
    /**
     * 验证文件类型
     */
    public boolean validateFileType(MultipartFile file) {
        String contentType = file.getContentType();
        
        // 检查MIME类型
        if (!ALLOWED_MIME_TYPES.contains(contentType)) {
            return false;
        }
        
        // 检查文件头（魔数）
        try {
            byte[] fileHeader = new byte[8];
            file.getInputStream().read(fileHeader);
            
            return validateFileHeader(fileHeader, contentType);
        } catch (IOException e) {
            return false;
        }
    }
    
    private boolean validateFileHeader(byte[] header, String mimeType) {
        // JPEG: FF D8 FF
        if (mimeType.equals("image/jpeg")) {
            return header[0] == (byte) 0xFF && 
                   header[1] == (byte) 0xD8 && 
                   header[2] == (byte) 0xFF;
        }
        
        // PNG: 89 50 4E 47
        if (mimeType.equals("image/png")) {
            return header[0] == (byte) 0x89 && 
                   header[1] == (byte) 0x50 && 
                   header[2] == (byte) 0x4E && 
                   header[3] == (byte) 0x47;
        }
        
        // 其他类型...
        return true;
    }
}
```

#### 4.1.2 文件名安全处理
```java
public class FileNameUtil {
    
    private static final Pattern INVALID_CHARS = 
        Pattern.compile("[/\\\\:*?\"<>|]");
    
    /**
     * 清理文件名
     */
    public static String sanitizeFileName(String fileName) {
        // 移除非法字符
        fileName = INVALID_CHARS.matcher(fileName).replaceAll("_");
        
        // 移除前后空格和点
        fileName = fileName.trim().replaceAll("^\\.+", "");
        
        // 限制长度
        if (fileName.length() > 255) {
            String extension = getExtension(fileName);
            String baseName = fileName.substring(0, 255 - extension.length() - 1);
            fileName = baseName + "." + extension;
        }
        
        return fileName;
    }
    
    /**
     * 生成安全的存储路径
     */
    public static String generateStoragePath(Long userId, String fileName) {
        String date = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
        String uuid = UUID.randomUUID().toString();
        String extension = getExtension(fileName);
        
        return String.format("%d/%s/%s.%s", userId, date, uuid, extension);
    }
}
```

### 4.2 文件扫描

#### 4.2.1 病毒扫描（集成ClamAV）
```java
@Service
public class AntivirusService {
    
    @Value("${clamav.host}")
    private String clamavHost;
    
    @Value("${clamav.port}")
    private int clamavPort;
    
    /**
     * 扫描文件
     */
    public boolean scanFile(File file) {
        try (Socket socket = new Socket(clamavHost, clamavPort)) {
            OutputStream out = socket.getOutputStream();
            InputStream in = socket.getInputStream();
            
            // 发送扫描命令
            out.write("zINSTREAM\0".getBytes());
            
            // 发送文件数据
            try (FileInputStream fis = new FileInputStream(file)) {
                byte[] buffer = new byte[2048];
                int read;
                
                while ((read = fis.read(buffer)) > 0) {
                    out.write(ByteBuffer.allocate(4).putInt(read).array());
                    out.write(buffer, 0, read);
                }
            }
            
            // 发送结束标记
            out.write(new byte[]{0, 0, 0, 0});
            out.flush();
            
            // 读取扫描结果
            byte[] response = new byte[1024];
            in.read(response);
            String result = new String(response).trim();
            
            return result.contains("OK");
        } catch (Exception e) {
            log.error("病毒扫描失败", e);
            return false;
        }
    }
}
```

### 4.3 下载安全

#### 4.3.1 防盗链
```java
@Component
public class DownloadSecurityInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        String referer = request.getHeader("Referer");
        
        // 检查Referer
        if (referer == null || !referer.startsWith("https://yourdomain.com")) {
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "非法请求");
            return false;
        }
        
        return true;
    }
}
```

#### 4.3.2 临时下载链接
```java
@Service
public class DownloadLinkService {
    
    @Autowired
    private RedisUtil redisUtil;
    
    /**
     * 生成临时下载链接
     */
    public String generateDownloadLink(Long fileId, Integer expireSeconds) {
        String token = UUID.randomUUID().toString();
        String key = "download:" + token;
        
        // 存储到Redis
        redisUtil.set(key, fileId, expireSeconds, TimeUnit.SECONDS);
        
        return "/download/" + token;
    }
    
    /**
     * 验证下载链接
     */
    public Long validateDownloadLink(String token) {
        String key = "download:" + token;
        Object fileId = redisUtil.get(key);
        
        if (fileId != null) {
            // 一次性链接，使用后删除
            redisUtil.delete(key);
            return Long.parseLong(fileId.toString());
        }
        
        return null;
    }
}
```

## 5. 接口安全

### 5.1 接口限流

#### 5.1.1 使用Redis实现限流
```java
@Aspect
@Component
public class RateLimitAspect {
    
    @Autowired
    private RedisTemplate<String, Integer> redisTemplate;
    
    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) 
            throws Throwable {
        HttpServletRequest request = 
            ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                .getRequest();
        
        String key = "rate_limit:" + request.getRemoteAddr() + ":" + 
                    point.getSignature().toShortString();
        
        Integer count = redisTemplate.opsForValue().get(key);
        
        if (count == null) {
            redisTemplate.opsForValue().set(key, 1, 
                rateLimit.time(), rateLimit.timeUnit());
        } else if (count < rateLimit.count()) {
            redisTemplate.opsForValue().increment(key);
        } else {
            throw new BusinessException("请求过于频繁，请稍后再试");
        }
        
        return point.proceed();
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    int count() default 100;
    int time() default 60;
    TimeUnit timeUnit() default TimeUnit.SECONDS;
}

// 使用示例
@RateLimit(count = 10, time = 60)
@PostMapping("/upload")
public Result<?> uploadFile(@RequestParam MultipartFile file) {
    // 上传逻辑
}
```

### 5.2 接口签名

#### 5.2.1 签名算法
```java
@Service
public class ApiSignService {
    
    @Value("${api.secret}")
    private String apiSecret;
    
    /**
     * 生成签名
     */
    public String generateSign(Map<String, String> params, long timestamp) {
        // 参数排序
        TreeMap<String, String> sortedParams = new TreeMap<>(params);
        
        // 拼接字符串
        StringBuilder sb = new StringBuilder();
        sortedParams.forEach((k, v) -> sb.append(k).append("=").append(v).append("&"));
        sb.append("timestamp=").append(timestamp);
        sb.append("&secret=").append(apiSecret);
        
        // MD5加密
        return DigestUtils.md5Hex(sb.toString());
    }
    
    /**
     * 验证签名
     */
    public boolean validateSign(Map<String, String> params, 
                               String sign, 
                               long timestamp) {
        // 检查时间戳（5分钟内有效）
        if (Math.abs(System.currentTimeMillis() - timestamp) > 300000) {
            return false;
        }
        
        String expectedSign = generateSign(params, timestamp);
        return expectedSign.equals(sign);
    }
}
```

## 6. 日志审计

### 6.1 操作日志记录

#### 6.1.1 日志切面
```java
@Aspect
@Component
@Slf4j
public class OperationLogAspect {
    
    @Autowired
    private FileOperationLogMapper logMapper;
    
    @Around("@annotation(operationLog)")
    public Object around(ProceedingJoinPoint point, OperationLog operationLog) 
            throws Throwable {
        HttpServletRequest request = 
            ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())
                .getRequest();
        
        Long userId = SecurityUtils.getCurrentUserId();
        String ipAddress = getIpAddress(request);
        String userAgent = request.getHeader("User-Agent");
        
        FileOperationLog log = new FileOperationLog();
        log.setUserId(userId);
        log.setOperationType(operationLog.type());
        log.setIpAddress(ipAddress);
        log.setUserAgent(userAgent);
        log.setCreateTime(LocalDateTime.now());
        
        try {
            Object result = point.proceed();
            log.setStatus(1);
            return result;
        } catch (Exception e) {
            log.setStatus(0);
            log.setErrorMsg(e.getMessage());
            throw e;
        } finally {
            logMapper.insert(log);
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OperationLog {
    String type();
    String desc() default "";
}

// 使用示例
@OperationLog(type = "delete", desc = "删除文件")
public void deleteFile(Long fileId) {
    // 删除逻辑
}
```

### 6.2 敏感操作告警

```java
@Service
public class SecurityAlertService {
    
    @Autowired
    private EmailService emailService;
    
    /**
     * 发送安全告警
     */
    public void sendAlert(String alertType, String message) {
        String subject = "【安全告警】" + alertType;
        String content = String.format(
            "告警时间：%s\n告警类型：%s\n详细信息：%s",
            LocalDateTime.now(),
            alertType,
            message
        );
        
        // 发送邮件给管理员
        emailService.sendToAdmin(subject, content);
        
        // 记录日志
        log.warn("安全告警：{} - {}", alertType, message);
    }
    
    /**
     * 检查异常登录
     */
    public void checkAbnormalLogin(Long userId, String ipAddress) {
        // 获取用户最近的登录IP
        String lastIp = getLastLoginIp(userId);
        
        // IP地址变化过大，发送告警
        if (lastIp != null && !isSameRegion(lastIp, ipAddress)) {
            sendAlert("异常登录", 
                String.format("用户%d从新IP地址%s登录", userId, ipAddress));
        }
    }
}
```

## 7. 安全配置清单

### 7.1 生产环境检查清单

- [ ] 修改默认管理员密码
- [ ] 配置HTTPS证书
- [ ] 开启防火墙
- [ ] 限制数据库访问IP
- [ ] 开启Redis密码认证
- [ ] 配置WAF规则
- [ ] 开启日志记录
- [ ] 定期备份数据
- [ ] 更新系统补丁
- [ ] 关闭不必要的端口
- [ ] 配置CDN
- [ ] 开启DDoS防护
- [ ] 设置文件上传限制
- [ ] 配置CORS策略
- [ ] 开启SQL审计
- [ ] 配置告警通知

### 7.2 application.yml安全配置

```yaml
spring:
  security:
    # 密码加密强度
    password-strength: 10
    
  servlet:
    multipart:
      # 文件上传限制
      max-file-size: 100MB
      max-request-size: 500MB

# JWT配置
jwt:
  secret: ${JWT_SECRET:your-very-long-secret-key-at-least-256-bits}
  expiration: 7200000  # 2小时
  refresh-expiration: 604800000  # 7天

# 限流配置
rate-limit:
  enabled: true
  default-limit: 100
  default-time: 60

# 安全配置
security:
  # 允许的文件类型
  allowed-file-types: jpg,jpeg,png,gif,pdf,doc,docx,xls,xlsx,ppt,pptx,txt,zip,rar
  # 禁止的文件类型
  blocked-file-types: exe,bat,sh,ps1,dll,so
  # 最大文件大小（字节）
  max-file-size: 104857600  # 100MB
  # 是否启用文件加密
  enable-file-encryption: false
  # 是否启用病毒扫描
  enable-antivirus: true

# ClamAV配置
clamav:
  host: localhost
  port: 3310
  enabled: true
```

## 8. 安全测试

### 8.1 渗透测试检查项

1. **认证测试**
   - 暴力破解防护
   - 会话管理
   - Token安全性

2. **授权测试**
   - 越权访问
   - 权限提升
   - 文件访问控制

3. **注入测试**
   - SQL注入
   - XSS攻击
   - 命令注入

4. **文件上传测试**
   - 恶意文件上传
   - 文件类型绕过
   - 路径遍历

### 8.2 安全扫描工具

- **OWASP ZAP**: Web应用安全扫描
- **Burp Suite**: 渗透测试工具
- **SQLMap**: SQL注入检测
- **Nmap**: 端口扫描
- **ClamAV**: 病毒扫描

## 9. 应急响应

### 9.1 安全事件处理流程

```
发现安全事件
      │
      ▼
   立即隔离
      │
      ▼
   评估影响
      │
      ▼
   修复漏洞
      │
      ▼
   恢复服务
      │
      ▼
   事后分析
```

### 9.2 常见安全事件处理

#### 9.2.1 账号被盗
1. 立即冻结账号
2. 重置密码
3. 撤销所有Token
4. 检查异常操作
5. 通知用户

#### 9.2.2 数据泄露
1. 停止数据传输
2. 修复漏洞
3. 评估泄露范围
4. 通知受影响用户
5. 报告相关部门

#### 9.2.3 DDoS攻击
1. 启用DDoS防护
2. 限制请求频率
3. 封禁攻击IP
4. 使用CDN分流
5. 联系运营商

